{{- func GetDTO }}
	{{- localDTOAttribute = $0.attributes | find "DTOAttribute" }}
	{{- if !localDTOAttribute}}
		#warning no DTO attribute was set on table model class {{$0}}
		{{-ret null}}
	{{-end}}
	{{-localDTO=(localDTOAttribute.parameters | find "Name").value}}
	{{-ret localDTO}}
{{-end }}

{{- func GetRelations
	result = []

	for foreignclass in project.classes | with_attribute "TableModelAttribute"
		for property in foreignclass.properties
			attribute = property.attributes | find "ForeignKey"
			if attribute
				isnullable = property.type_name | string.ends_with "?"

				relation = { 
					ForeignTable: foreignclass | GetDTO,
					ForeignKey: property.name,
					ForeignPropertyName: (attribute.parameters | find "ForeignPropertyName").value, 
					ForeignKeyIsNullable: isnullable,
					ForeignKeyType: property.type_name,
					PrimaryPropertyName: (attribute.parameters | find "PrimaryPropertyName").value, 
					PrimaryTable: (attribute.parameters | find "PrimaryTable").value, 
					PrimaryKey: (attribute.parameters | find "PrimaryKey").value, 
					CascadeTrigger: (attribute.parameters | find "CascadeTrigger").value 
				} 
				result = result + [relation]
			end
		end
	end

	ret result
end }}

{{- databaseName = class | GetDTO }}
{{- if !databaseName}}
#warning no DTO attribute was set on unit test class {{class.name}}
{{-ret}}
{{-end}}


{{- -}}


// <auto-generated/>
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using DataLib;
{{- for reference in project.references }}
using {{reference}};
{{-end}}
{{-for usingAttribute in class.attributes | with_name "UsingAttribute" }}
using {{(usingAttribute.parameters | find "Namespace").value}};
{{-end}}

namespace {{class.namespace}}
{
	public partial class {{class.name}}
	{
		{{- for class in project.classes | with_attribute "TableModelAttribute" }}
		{{- dto=class | GetDTO }}
		// events definition for table {{dto}}
		public event TableChangedEventHandler<Tables.{{dto}}> {{dto}}TableChanging;
		public event TableChangedEventHandler<Tables.{{dto}}> {{dto}}TableChanged;
		public event RowChangedEventHandler<Tables.{{dto}}> {{dto}}RowChanging;
		public event RowChangedEventHandler<Tables.{{dto}}> {{dto}}RowChanged;
		{{- end }}

		// Dictionaries
		{{- for class in project.classes | with_attribute "TableModelAttribute" }}
		{{- dto=class | GetDTO }}
		private Dictionary<Tables.{{dto}},{{class.name}}> {{dto}}Dictionary;
		{{- end }}


		private Tables.{{databaseName}} dataSource;

		public {{class.name}}(Tables.{{databaseName}} DataSource)
		{
			this.dataSource=DataSource;

			{{- for class in project.classes | with_attribute "TableModelAttribute" }}
			{{- dto=class | GetDTO }}
			{{dto}}Dictionary =  new Dictionary<Tables.{{dto}},{{class.name}}> ();
			{{- end }}
		}			

	
		{{- for table in project.classes | with_attribute "TableModelAttribute" }}
		{{- dto=table | GetDTO }}
		#region table {{dto}}
		{{- primarykey = table.properties | with_attribute "PrimaryKey" | array.first }}
		{{- if primarykey }}
		public void Remove{{dto}}({{table.name}} Item)
		{
			#nullable enable
			Tables.{{dto}}? dataSourceItem;
			#nullable disable
			int index;

					
			dataSourceItem=dataSource.{{dto}}Table.FirstOrDefault(item=>item.{{primarykey.name}} == Item.{{primarykey.name}});
			if (dataSourceItem == null) return;
			index=dataSource.{{dto}}Table.IndexOf(dataSourceItem);

			if ({{dto}}TableChanging != null) {{dto}}TableChanging(dataSourceItem,TableChangedActions.Remove, index);
				
			dataSource.{{dto}}Table.Remove(dataSourceItem);
				
			// cascade update should be triggered before cascade delete
			#region cascade update actions
			{{-for relation in GetRelations}}
			{{- if relation.PrimaryTable==dto}}
			{{- if relation.CascadeTrigger=="CascadeTriggers.Update"}}
			{{- if relation.ForeignKeyIsNullable}}
			// Cascade update from relation {{relation.ForeignTable}}.{{relation.ForeignKey}} -> {{relation.PrimaryTable}}.{{relation.PrimaryKey}}
			foreach({{relation.ForeignTable}}Model foreignItem in Get{{relation.ForeignTable}}Table(foreignItem=>foreignItem.{{relation.ForeignKey}} == Item.{{relation.PrimaryKey}}).ToArray())
			{
				foreignItem.{{relation.ForeignKey}} = null;
			}
			{{-else}}
			// Cascade update from relation  {{relation.ForeignTable}}.{{relation.ForeignKey}} -> {{relation.PrimaryTable}}.{{relation.PrimaryKey}}
			{{relation.ForeignKeyType}} fallBackValue = Get{{relation.PrimaryTable}}Table().First(item=>item!=Item).{{relation.PrimaryKey}};
			foreach({{relation.ForeignTable}}Model foreignItem in Get{{relation.ForeignTable}}Table(foreignItem=>foreignItem.{{relation.ForeignKey}} == Item.{{relation.PrimaryKey}}).ToArray())
			{
				foreignItem.{{relation.ForeignKey}} = fallBackValue;
			}
			{{-end}}
			{{-end}}
			{{-end}}
			{{-end}}

			{{-for relation in GetRelations}}
			{{- if relation.PrimaryTable==dto}}
			{{- if relation.CascadeTrigger=="CascadeTriggers.Delete"}}
			// Cascade delete from relation {{relation.ForeignTable}}.{{relation.ForeignKey}} -> {{relation.PrimaryTable}}.{{relation.PrimaryKey}}
			foreach({{relation.ForeignTable}}Model foreignItem in Get{{relation.ForeignTable}}Table(foreignItem=>foreignItem.{{relation.ForeignKey}} == Item.{{relation.PrimaryKey}}).ToArray())
			{
				foreignItem.Delete();
			}
			{{-end}}
			{{-end}}
			{{-end}}
			#endregion

			if ({{dto}}TableChanged != null) {{dto}}TableChanged(dataSourceItem,TableChangedActions.Remove, index);
		}
		{{- end }}

		public {{table.name}} Get{{dto}}(Func<Tables.{{dto}},bool> Predicate)
		{
			return Create{{table.name}}(dataSource.{{dto}}Table.First(Predicate));
		}
		{{- if primarykey }}
		public {{table.name}} Get{{dto}}({{primarykey.type_name}} {{primarykey.name}})
		{
			return Get{{dto}}(item=>item.{{primarykey.name}} == {{primarykey.name}});
		}
		{{- end }}

		public IEnumerable<{{table.name}}> Get{{dto}}Table()
		{
			return dataSource.{{dto}}Table.Select(item=> Create{{table.name}}(item));
		}
		public IEnumerable<{{table.name}}> Get{{dto}}Table(Func<Tables.{{dto}},bool> Predicate)
		{
			return dataSource.{{dto}}Table.Where(Predicate).Select(item=>Create{{table.name}}(item));
		}
		public void Add{{dto}}(Tables.{{dto}} Item)
		{
			int index;

			if (dataSource.{{dto}}Table.Contains(Item)) return;

			index = dataSource.{{dto}}Table.Count;
			if ({{dto}}TableChanging != null) {{dto}}TableChanging(Item,TableChangedActions.Add, index);
			dataSource.{{dto}}Table.Add(Item);
			if ({{dto}}TableChanged != null) {{dto}}TableChanged(Item,TableChangedActions.Add, index);
		}
		{{removeMethod}}

		public void Notify{{dto}}RowChanging(Tables.{{dto}} Item, string PropertyName, object OldValue, object NewValue)
		{
			if ({{dto}}RowChanging != null) {{dto}}RowChanging(Item,PropertyName,OldValue,NewValue);
		}
		public void Notify{{dto}}RowChanged(Tables.{{dto}} Item, string PropertyName, object OldValue, object NewValue)
		{
			if ({{dto}}RowChanged != null) {{dto}}RowChanged(Item,PropertyName,OldValue,NewValue);
		}
			
		public {{table.name}} Create{{table.name}}(Tables.{{dto}} Item)
		{
			{{table.name}} model;
			
			if (Item==null) throw new ArgumentNullException(nameof(Item));
			
			if (!{{dto}}Dictionary.TryGetValue(Item,out model))
			{
				model=new {{table.name}}(this, Item);
				{{dto}}Dictionary.Add(Item,model);
			}

			return model;
		}
		#endregion

		{{- end }}

		


	}
}