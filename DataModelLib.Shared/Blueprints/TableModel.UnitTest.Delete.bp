{{- func GetMockCount
	ret (($0.attributes | find "MockCountAttribute")?.parameters | find "Value")?.value??"5" | string.to_int
end -}}

{{- func GetDTO }}
	{{- localDTOAttribute = $0.attributes | find "DTOAttribute" }}
	{{- if !localDTOAttribute}}
		#warning no DTO attribute was set on table model class {{$0}}
		{{-ret null}}
	{{-end}}
	{{-localDTO=(localDTOAttribute.parameters | find "Name").value}}
	{{-ret localDTO}}
{{-end }}

{{- func GetRelations
	result = []

	for foreignclass in project.classes | with_attribute "TableUnitTestAttribute"
		for property in foreignclass.properties
			attribute = property.attributes | find "ForeignKey"
			if attribute
				isnullable = property.type_name | string.ends_with "?"

				relation = { 
					ForeignTable: foreignclass | GetDTO,
					ForeignKey: property.name,
					ForeignPropertyName: (attribute.parameters | find "ForeignPropertyName").value, 
					ForeignKeyIsNullable: isnullable,
					ForeignKeyType: property.type_name,
					PrimaryPropertyName: (attribute.parameters | find "PrimaryPropertyName").value, 
					PrimaryTable: (attribute.parameters | find "PrimaryTable").value, 
					PrimaryKey: (attribute.parameters | find "PrimaryKey").value, 
					CascadeTrigger: (attribute.parameters | find "CascadeTrigger").value 
				} 
				result = result + [relation]
			end
		end
	end

	ret result
end }}


{{- func where_is_primary
	result = []

	for relation in $0
		if relation.PrimaryTable==dto
			result = result + [relation]
		end
	end

	ret result
end -}}

{{- func where_is_foreign
	result = []

	for relation in $0
		if relation.ForeignTable==dto
			result = result + [relation]
		end
	end

	ret result
end -}}

{{- databaseModels = (project.classes  | with_attribute "DatabaseUnitTestAttribute") }}
{{- databaseModel = databaseModels | array.first }}
{{- if !databaseModel  }}
#warning no DatabaseModel attribute defined in database model class
{{-ret}}
{{-end}}
{{databaseName = databaseModel | GetDTO}}

{{- dto= class | GetDTO }}

{{- mockCount = GetMockCount class }}
{{-primaryKey=class.properties | with_attribute "PrimaryKey" | array.first}}

{{- -}}

// <auto-generated/>
using System;
using System.Collections.Generic;
//
{{-for usingAttribute in class.attributes | with_name "UsingAttribute" }}
using {{(usingAttribute.parameters | find "Namespace").value}};
{{-end}}


namespace {{class.namespace}}
{
	public partial class {{class.name}}
	{

		#region {{dto}} table
		{{-if primaryKey}}
		
		[TestMethod]
		public void ShouldDelete()
		{
			Models.{{databaseName}}Model testDatabaseModel;
			Models.{{dto}}Model[] models;

			testDatabaseModel = new Models.{{databaseName}}Model(MockDatabase.Create());

			// delete last item
			testDatabaseModel.Get{{dto}}({{mockCount}}).Delete();
			models = testDatabaseModel.Get{{dto}}Table().ToArray();
			Assert.AreEqual({{mockCount-1}}, models.Length);
			Assert.AreEqual(1, models[0].{{primaryKey.name}});
		}

		[TestMethod]
		public void ShouldRaiseTableChangingOnDelete()
		{
			Models.{{databaseName}}Model testDatabaseModel;
			Models.{{dto}}Model[] models;
			int changedIndex = -1;
			#nullable enable
			Tables.{{dto}}? changedItem = null;
			DataLib.TableChangedActions? changedAction = null;
			#nullable disable

			testDatabaseModel = new Models.{{databaseName}}Model(MockDatabase.Create());
			testDatabaseModel.{{dto}}TableChanging += (item, action, index) => { changedItem = item; changedAction = action; changedIndex = index; ; };

			// delete last item
			testDatabaseModel.Get{{dto}}({{mockCount}}).Delete();
			models = testDatabaseModel.Get{{dto}}Table().ToArray();
			Assert.AreEqual({{mockCount-1}}, models.Length);
	
			Assert.IsNotNull(changedItem);
			Assert.AreEqual({{mockCount}}, changedItem.{{primaryKey.name}});
			Assert.AreEqual(DataLib.TableChangedActions.Remove, changedAction);
			Assert.AreEqual({{mockCount-1}}, changedIndex);
		}

		[TestMethod]
		public void ShouldRaiseTableChangedOnDelete()
		{
			Models.{{databaseName}}Model testDatabaseModel;
			Models.{{dto}}Model[] models;
			int changedIndex = -1;
			#nullable enable
			Tables.{{dto}}? changedItem = null;
			DataLib.TableChangedActions? changedAction = null;
			#nullable disable

			testDatabaseModel = new Models.{{databaseName}}Model(MockDatabase.Create());
			testDatabaseModel.{{dto}}TableChanged += (item, action, index) => { changedItem = item; changedAction = action; changedIndex = index; ; };

			// delete last item
			testDatabaseModel.Get{{dto}}({{mockCount}}).Delete();
			models = testDatabaseModel.Get{{dto}}Table().ToArray();
			Assert.AreEqual({{mockCount-1}}, models.Length);
	
			Assert.IsNotNull(changedItem);
			Assert.AreEqual({{mockCount}}, changedItem.{{primaryKey.name}});
			Assert.AreEqual(DataLib.TableChangedActions.Remove, changedAction);
			Assert.AreEqual({{mockCount-1}}, changedIndex);
		}

		// manage cascade triggers
		{{- for relation in GetRelations | where_is_primary}}
		{{- if relation.CascadeTrigger=="CascadeTriggers.Delete"}}
		[TestMethod]
		public void ShouldCascadeDelete{{relation.ForeignTable}}OnForeignKey{{relation.ForeignKey}}()
		{
			Models.{{databaseName}}Model testDatabaseModel;
			Models.{{dto}}Model model;
			#nullable enable
			Tables.{{relation.ForeignTable}}? changedItem=null;
			DataLib.TableChangedActions? changedAction;
			#nullable disable
			int deletedCount = 0;
			int foreignItemsCount = 0;
			int foreignTableCount = 0;
			int newForeignTableCount = 0;

			testDatabaseModel = new Models.{{databaseName}}Model(MockDatabase.Create());
			testDatabaseModel.{{relation.ForeignTable}}TableChanged += (item, action, index) => { changedItem = item; changedAction = action; deletedCount++; };

			model = testDatabaseModel.Get{{dto}}(1);
			foreignItemsCount = model.Get{{relation.PrimaryPropertyName}}().Count();
			foreignTableCount = testDatabaseModel.Get{{relation.ForeignTable}}Table().Count();

			// delete model
			model.Delete();

			newForeignTableCount = testDatabaseModel.Get{{relation.ForeignTable}}Table().Count();

			Assert.AreEqual(foreignItemsCount, deletedCount);
			Assert.IsNotNull(changedItem);
			Assert.AreEqual(newForeignTableCount + deletedCount,foreignTableCount );
		}
		[TestMethod]
		public void ShouldNotCascadeDelete{{relation.ForeignTable}}OnForeignKey{{relation.ForeignKey}}()
		{
			Models.{{databaseName}}Model testDatabaseModel;
			Models.{{dto}}Model model;
			Tables.{{dto}} item;
			#nullable enable
			Tables.{{relation.ForeignTable}}? changedItem=null;
			DataLib.TableChangedActions? changedAction;
			#nullable disable
			int deletedCount = 0;
			int foreignItemsCount = 0;
			int foreignTableCount = 0;
			int newForeignTableCount = 0;

			testDatabaseModel = new Models.{{databaseName}}Model(MockDatabase.Create());
			testDatabaseModel.{{relation.ForeignTable}}TableChanged += (item, action, index) => { changedItem = item; changedAction = action; deletedCount++; };

			// create new item with no foreign item attached
			item = MockDatabase.Create{{dto}}({{mockCount+1}});
			model =testDatabaseModel.Create{{dto}}Model(item);
			testDatabaseModel.Add{{dto}}(item);

			foreignItemsCount = model.Get{{relation.PrimaryPropertyName}}().Count();
			foreignTableCount = testDatabaseModel.Get{{relation.ForeignTable}}Table().Count();

			// delete model
			model.Delete();

			newForeignTableCount = testDatabaseModel.Get{{relation.ForeignTable}}Table().Count();

			Assert.AreEqual(0, deletedCount);
			Assert.IsNull(changedItem);
			Assert.AreEqual(newForeignTableCount ,foreignTableCount );
		}
		{{- else if relation.CascadeTrigger=="CascadeTriggers.Update"}}
		[TestMethod]
		public void ShouldCascadeUpdate{{relation.ForeignTable}}OnForeignKey{{relation.ForeignKey}}()
		{
			Models.{{databaseName}}Model testDatabaseModel;
			Models.{{relation.ForeignTable}}Model[] foreignItems;
			Models.{{dto}}Model model;
			#nullable enable
			Tables.{{relation.ForeignTable}}? changedItem=null;
			#nullable disable
			int updatedCount = 0;
			int foreignItemsCount = 0;

			testDatabaseModel = new Models.{{databaseName}}Model(MockDatabase.Create());
			testDatabaseModel.{{relation.ForeignTable}}RowChanged += (item, propertyName, oldV,newV) => { changedItem = item;  updatedCount++; };

			model = testDatabaseModel.Get{{dto}}(2);
			foreignItems = model.Get{{relation.PrimaryPropertyName}}().ToArray();
			foreignItemsCount = foreignItems.Length;

			// delete model
			model.Delete();

			Assert.AreEqual(foreignItemsCount, updatedCount);
			Assert.IsNotNull(changedItem);
			{{-if relation.ForeignKeyIsNullable}}
			// foreign key should be set to null value
			Assert.IsTrue(foreignItems.All(item=>item.{{relation.ForeignKey}} is null));
			{{-else}}
			// foreign key should be set to default value
			Assert.IsTrue(foreignItems.All(item=>item.{{relation.ForeignKey}}==1));
			{{-end}}

		}
		[TestMethod]
		public void ShouldNotCascadeUpdate{{relation.ForeignTable}}OnForeignKey{{relation.ForeignKey}}()
		{
			Models.{{databaseName}}Model testDatabaseModel;
			Models.{{dto}}Model model;
			Tables.{{dto}} item;
			#nullable enable
			Tables.{{relation.ForeignTable}}? changedItem=null;
			#nullable disable
			int updatedCount = 0;
	
			testDatabaseModel = new Models.{{databaseName}}Model(MockDatabase.Create());
			testDatabaseModel.{{relation.ForeignTable}}RowChanged += (item, propertyName, oldV,newV) => { changedItem = item;  updatedCount++; };

			// create new item with no foreign item attached
			item = MockDatabase.Create{{dto}}({{mockCount+1}});
			model =testDatabaseModel.Create{{dto}}Model(item);
			testDatabaseModel.Add{{dto}}(item);

	
			// delete model
			model.Delete();

			Assert.AreEqual(0, updatedCount);
			Assert.IsNull(changedItem);
		}
		{{-end}}
		{{-end}}


		{{-else}}
		#warning No primary key defined for table {{dto}}
		{{-end}}
		

		#endregion

	}
}
