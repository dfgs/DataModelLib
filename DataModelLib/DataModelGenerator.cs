using DataModelLib.DataModels;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Xml.Linq;

namespace DataModelLib
{
	[Generator]
	public class DataModelGenerator : IIncrementalGenerator
	{
		
		private const string Namespace = "DataModelGenerator";

		private const string DatabaseAttributeSourceCode =
		$$"""
		// <auto-generated/>
		using System;
		
		namespace {{Namespace}}
		{
		  
			[AttributeUsage(AttributeTargets.Class, Inherited = false)]
			public class DatabaseAttribute : Attribute
			{
			}
		}
		""";
		private const string TableAttributeSourceCode =
		$$"""
		// <auto-generated/>
		using System;
		
		namespace {{Namespace}}
		{
		  
			[AttributeUsage(AttributeTargets.Property, Inherited = false)]
			public class TableAttribute : Attribute
			{
				
			}
		}
		""";
		




		public void Initialize(IncrementalGeneratorInitializationContext context)
		{
			context.RegisterPostInitializationOutput(ctx => ctx.AddSource("Attributes/DatabaseAttribute.g.cs", SourceText.From(DatabaseAttributeSourceCode, Encoding.UTF8)));
			context.RegisterPostInitializationOutput(ctx => ctx.AddSource("Attributes/TableAttribute.g.cs", SourceText.From(TableAttributeSourceCode, Encoding.UTF8)));

			IncrementalValuesProvider<SyntaxNode> syntaxNodeProvider = context.SyntaxProvider.CreateSyntaxProvider
			(
				(syntaxNode,cancellationToken) => (syntaxNode is ClassDeclarationSyntax classDeclatationSyntax) && classDeclatationSyntax.AttributeLists.Count > 0,
				transform: static (ctx, _) => GetDeclarationForSourceGen(ctx)
			)
			.Where(classDeclarationSyntax=>classDeclarationSyntax.AttributeFound)
			.Select((t, _) => t.Node);


			context.RegisterSourceOutput
			(
				context.CompilationProvider.Combine(syntaxNodeProvider.Collect()),
				(ctx, t) => GenerateCode(ctx, t.Left, t.Right.OfType<TypeDeclarationSyntax>())
			);
			
			
		}
	
		private static (SyntaxNode Node, bool AttributeFound) GetDeclarationForSourceGen(GeneratorSyntaxContext context)
		{
			SyntaxNode currentNode = context.Node;

			bool attributeFound = currentNode.ContainsAttribute(context.SemanticModel, $"{Namespace}.DatabaseAttribute");
				//.EnumerateAttributeSyntax().Any(attributeList => attributeList.Attributes.Any(attributeSyntax => attributeSyntax.ContainsAttribute(context.SemanticModel, $"{Namespace}.DatabaseAttribute") ));

			return (currentNode, attributeFound);
		}


		private static void GenerateCode(SourceProductionContext context, Compilation compilation, IEnumerable<TypeDeclarationSyntax> declarations)
		{
			SemanticModel semanticModel;
			string nameSpace;
			string className;
			DatabaseModel databaseModel;
			INamedTypeSymbol? typeSymbol;
			string itemType;

			foreach (TypeDeclarationSyntax declarationSyntax in declarations)
			{
				// On récupère le modèle sémantique pour pouvoir manipuler les méta données et le contenu de nos objets 
				semanticModel = compilation.GetSemanticModel(declarationSyntax.SyntaxTree);
				if (semanticModel.GetDeclaredSymbol(declarationSyntax) is not INamedTypeSymbol symbol) continue;

				// On récupère le namespace, le nom du noeud courant et on créé le nom du futur DTO
				nameSpace = symbol.ContainingNamespace.ToDisplayString();
				className = declarationSyntax.Identifier.Text;

				databaseModel = new DatabaseModel(nameSpace,className);
				
				foreach(PropertyDeclarationSyntax propertyDeclarationSyntax in declarationSyntax.Members.OfType<PropertyDeclarationSyntax>())
				{
					if (!propertyDeclarationSyntax.ContainsAttribute(semanticModel, $"{Namespace}.TableAttribute")) continue;

					// get type symbol from property
					typeSymbol = propertyDeclarationSyntax.GetTypeSymbol(semanticModel);
					//  if symbol cannot be found, skip property
					if (typeSymbol== null) continue;
					// if property type is not enumerable<T>, skip property
					if (!typeSymbol.IsGenericType) continue;
					if (typeSymbol.TypeArguments.Length != 1) continue;
					itemType=typeSymbol.TypeArguments[0].ToString();
					bool isEnumerable = typeSymbol.AllInterfaces.Any(item => item.ToString() == "System.Collections.IEnumerable");
					bool isList = typeSymbol.AllInterfaces.Any(item => item.ToString() == "System.Collections.IList");
					if (!isEnumerable) continue;

					databaseModel.TableModels.Add(new TableModel(propertyDeclarationSyntax.Identifier.Text, itemType,isEnumerable,isList));
				}


				string source = databaseModel.GenerateCode();

				// On ajoute enfin notre nouveau dto à notre code source
				context.AddSource($"{className}Model.g.cs", SourceText.From(source, Encoding.UTF8));
			}
		}


	





	}
}